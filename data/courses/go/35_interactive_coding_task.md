---
name: Интерактивная задача на кодинг, приближенный к условиям работы
module: Практика
tags:
  - грейды
  - озон
---
Есть набор URL:

```go
package main  
  
func main() {  
    var urls = []string{  
       "http://ozon.ru",  
       "https://ozon.ru",  
       "http://google.com",  
       "http://somesite.com",  
       "http://non-existent.domain.tld",  
       "https://ya.ru",  
       "http://ya.ru",  
       "http://ёёёё",  
    }  
}
```

Напишите программу, которая:
1. Поочередно выполнит http запросы по предложенному списку ссылок: в случае получения http-кода ответа на запрос "200 OK" печатаем на экране "адрес url - ok"; в случае получения http-кода ответа на запрос отличного от "200 OK" либо в случае ошибки печатаем на экране "адрес url - not ok"
2. Модифицируйте программу таким образом, чтобы использовались каналы для коммуникации основного потока с горутинами. Пример:
	• Запросы по списку выполняются в горутинах.
	• Печать результатов на экран происходит в основном потоке
3. Модифицируйте программу таким образом, чтобы нигде не использовалась длина слайса урлов. Считайте, что урлы приходят из внешнего источника. Сколько их будет заранее - неизвестно. Предложите идиоматичный вариант, как ваша программа будет узнавать об окончании списка и передавать сигнал об окончании действий далее.
4. (необязательно, можно обсудить устно, чтобы убедиться, что кандидат понимает идею контекста, либо предложить как домашнее задание) Модифицируйте программу таким образом, что бы при получении 2 первых ответов с "200 OK" остальные запросы штатно прерывались. При этом необходимо напечатать на экране сообщение о завершении запроса.
5. (необязательно, можно обсудить устно) Предложите отрефакторить код. Какие тесты кандидат написал бы к этому коду?
6. Предложите написать код теста и интерфейсы, для которых будут генериться моки. (Как показывает практика это самая сложная часть задачи)

**17 грейд**

Написал синхронное решение, которое идет последовательно и выполняет http-запросы.

**18 грейд**

Написал решение с использованием канала (куда отправляются ссылки для скачивания), горутин (воркеров), которые выполняют запросы и sync.WaitGroup для ожидания завершения.
Может реализовать остановку выполнения воркеров через context или управляющий канал.

**19 грейд**

Может написать решение, чтобы ограничивать количество исходящих запросов.
Может самостоятельно написать моки.

**Дополнительные вопросы**

Первый пункт очень прост и хорош для разминки кандидата, ознакомления с сервисов, чтобы кандидат запустил код, посмотрел как работает. По каждому пункту можно дополнительно обсудить использованные им примитивы, почему выбрано то или иное решение. Например:

• какие вообще есть примитивы синхронизации в go, как их можно использовать
• как используются закрытые каналы
• что будет если писать или читать в закрытый канал
• как сделать счетчик, агрегирующий информацию из разных горутин (либо atomic либо отдельная горутина)
• как использовать контекст