---
name: Как устроен LRU cache?
module: Теория
tags:
  - грейды
---
Кеш имеет фиксированный максимальный размер.

Если после вставки нового элемента превышается максимально допустимый размер кеша, из него нужно удалить самый старый элемент.

Пример:

```js
cache = new LRU(capacity=2)
cache.put(A, 1); // cache is {A=1}
cache.put(B, 2); // cache is {A=1, B=2}
cache.get(A); // return 1
cache.put(C, 3); // {A=1, C=3}, element B=2 was evicted
cache.get(B); // returns -1 (not found)
cache.put(D, 4); // {D=4, C=3}
cache.get(A); // return -1 (not found)
cache.get(C); // return 3
cache.get(D); // return 4
```

**17 грейд**

Если кандидат затрудняется с ответом, то спросить а какие вообще структуры данных он знает и сложность операций в них. Как минимум (массив, словарь/мапа, деревья).

**18 грейд**

Используем хештаблицу как основную структуру для кеша. Ключи в ней будут теми же, что и в LRU кеше, но со значениями сложнее - их мы оборачиваем в структуру Node - узел двусвязного списка. Node будет хранить ключ, значение, и ссылки на prev/next узлы.

Нам нужно реализовать работу с последовательностью операций, чтобы определять самый старый элемент. Здесь и нужен двусвязный список - элементы в нём располагаются в хронологическом порядке операций. Самый старый элемент будет в голове списка, новые и обновленные элементы будут перемещаться в хвост списка.

Если мы читаем по ключу не в первый раз, то нам может понадобиться переместить его из середины списка в хвост. Находим за O(1) нужный узел по ключу, за O(1) удаляем его из середины списка (обновляем ссылки соседних узлов) и перемещаем в конец.
