---
name: Задача на неблокирующий вызов функции
module: Практика
tags:
  - avito
  - medium
---

- Есть функция `unpredictableFunc`, работающая неопределённо долго и возвращающая число. Её тело нельзя изменять (представим, что внутри сетевой запрос).
- Нужно написать обёртку `predictableFunc`, которая будет работать с заданным фиксированным таймаутом (например, 1 секунду).

Вот заготовка:

```go
package main

import (
	"fmt"
	"math/rand"
	"time"
)

func init() {
	rand.Seed(time.Now().UnixNano())
}

// Есть функция, работающая неопределённо долго и возвращающая число.
// Её тело нельзя изменять (представим, что внутри сетевой запрос).
func unpredictableFunc() int64 {
	rnd := rand.Int63n(5000)
	time.Sleep(time.Duration(rnd) * time.Millisecond)
	return rnd
}

// Нужно изменить функцию обёртку, которая будет работать с заданным таймаутом (например, 1 секунду).
// Если "длинная" функция отработала за это время - отлично, возвращаем результат.
// Если нет - возвращаем ошибку. Результат работы в этом случае нам не важен.
//
// Дополнительно нужно измерить, сколько выполнялась эта функция (просто вывести в лог).
// Сигнатуру функцию обёртки менять можно.
func predictableFunc() int64 {
	return unpredictableFunc()
}

func main() {
	fmt.Println("started")
	fmt.Println(predictableFunc())
}
```

Что проверяем:

1. Базовое знание горутин
2. Применение каналов для передачи результата из горутины
3. Понимание работы context
4. Работа с select для мультиплексирования каналов
5. Работа с временем выполнения операций (прообраз работы с метриками)

Возможные вариации решения:

- кандидат может сказать, что было бы здорово заменить сигнатуру `unpredictableFunc`, чтобы она принимала `context.Context` и работала с ним "нативно". Отмечаем плюсик, отвечаем "это хороший вариант, но давай представим, что это по какой-то причине невозможно. Как бы ты это обошёл?"
- нормальный вариант, если кандидат просто принимает контекст на вход функции, а таймаут задаёт снаружи в `main()` (то есть нет дефолтного таймаута, как в примере решения)
- можно вместо ctx принимать на вход таймаут и работать с `<-time.After(t)` - главное, чтобы была асинхронная обработка с каналом. В этом случае нужно спросить, знает ли про Context.

Возможные ошибки

- При создании контекста забыл обработать context.CancelFunc - стоит уточнить, зачем она нужна (ответ - чтобы корректно завершить работу таймера внутри контекста и освободить ресурсы)
- При логгировании времени сделал что-то типа defer `fmt.Println("elapsed:", time.Since(time.Now()))` - нужно будет спросить про работу defer и разрешение параметров вызова
- Создан небуферизированный канал - и горутина навсегда заблокировалась на запись в случае таймаута
- Нет проверки ошибок

Дополнительные вопросы

1. Как работает select, если в нескольких каналах одновременно есть данные ||(ответ - недетерминировано, на порядок обработки нельзя закладываться)||