---
name: Какие существуют общие типы ограничений (constraint) в реляционных базах данных?
module: Базы данных
tags:
  - грейды
  - озон
---
Какие существуют общие типы ограничений (constraint) в реляционных базах данных?
Расскажите кратко о назначении каждого ограничения.

Для реляционных баз данных существуют следующие общие constraint:

• Ограничения-проверки (CHECK): наиболее общий тип ограничений, предназначен для
контроля задаваемого полю таблицы значения заданному в выражении условию;
• NOT NULL: указывает, что столбцу нельзя присваивать значение NULL;
• Ограничения уникальности (UNIQUE): гарантируют, что данные в определённом столбце
или группе столбцов уникальны среди всех строк таблицы;
• Первичные ключи (PRIMARY KEY): означает, что образующий ограничение столбец (или
группа столбцов) может быть уникальным идентификатором строк в таблице;
• Внешние ключи (FOREIGN KEY): указывает, что значения столбца (или группы столбцов)
должны соответствовать значениям в некоторой строке другой таблицы
• \*Ограничения-исключения (Postgres) (EXCLUDE): гарантирует, что при сравнении любых
двух строк по указанным столбцам или выражениям с помощью заданных операторов,
минимум одно из этих сравнений возвратит false или NULL

Дополнительные вопросы

Q: Что произойдет если нарушить CHECK?
A Ошибка модификации данных на уровне самой базы данных и rollback транзакции

Q: Можно ли как-то визуально улучшить сообщения об ошибках нарушения ограничения CHECK средствами БД?
A: Можно задать ограничению отдельное имя - в этом случае при ошибке будет
возвращено имя нарушенного ограничения.

Q: Может ли ограничение CHECK или UNIQUE работать на всю таблицу целиком? Если да,
приведите пример.
A: CHECK (так же как и UNIQUE) может ссылаться на несколько столбцов, в этом случае
ограничение проверяет данные всех включенных столбцов при модификации:

```sql
CREATE TABLE TEST_TABLE  
(  
    A bigint,  
    B bigint,  
    C bigint,  
    CHECK (A - B >= C),  
    UNIQUE (b, c)  
);
```

Q: Что такое значение NULL?
A: Это указатель на отсутствие реального значения поля таблицы.

Q: Допустим мы создаем таблицу:

```sql
CREATE TABLE TEST_TABLE  
(  
    A serial,  
    B bigint,  
    C bigint  
);  
  
-- Делаем вставку.  
insert into test_table(b) values (5);  
  
-- Что вернёт следующий запрос?  
select b - c as delta from test_table;
```

A: Запрос вернет NULL: недопустимо осуществлять операции сравнения или
арифметические с столбцами, где разрешено хранить NULL без обертки такого столбца в
COALESCE или аналогичную по назначению функцию. Автоматического преобразования к
значению по умолчанию базового типа данных столбца не происходит.

Q: (На внимательность) Допустим мы создаем таблицу:

```sql
CREATE TABLE TEST_TABLE  
(  
    A serial,  
    B bigint,  
    C bigint,  
    PRIMARY KEY (a, c)  
);  
  
-- И выполняем команду на вставку строки:  
insert into test_table(b) values (5);  
  
-- Что вернет следующий запрос?  
select b - COALESCE(c, 0) as delta from test_table;
```

A: Ничего не вернет, так как команда insert не отработает - будет ошибка нарушения
первичного ключа: для данных в ключе недопустимы NULL-ы

Q: Что происходит с таблицей при добавлении первичного ключа?
A: Автоматически создаётся уникальный индекс (B-дерево) для столбца (или группы столбцов), перечисленных в первичном ключе, и данные столбцы помечаются как NOT NULL

Q: Для чего нужны FOREIGN KEY?
A: Для поддержания ссылочной целостности данных средствами самой базы данных.

Q: Допустим мы имеем базу данных из следующих таблиц:

```sql
CREATE TABLE products  
(  
    product_no integer PRIMARY KEY,  
    name       text,  
    price      numeric  
);  
  
CREATE TABLE orders  
(  
    order_id         integer PRIMARY KEY,  
    shipping_address text  
);  
  
CREATE TABLE order_items  
(  
    product_no integer REFERENCES products,  
    order_id   integer REFERENCES orders,  
    quantity   integer,  
    PRIMARY KEY (product_no, order_id)  
);
```

Как сделать так, чтобы:

• при удалении записи из таблицы products гарантированно не удалялись все записи из таблицы order_items с тем же продуктом?
• при удалении из таблицы заказов автоматически удалялись все записи этого заказа из order_items?

A: Модифицировать таблицу order_items следующим образом:

```sql
CREATE TABLE order_items  
(  
    product_no integer REFERENCES products ON DELETE RESTRICT,  
    order_id   integer REFERENCES orders ON DELETE CASCADE,  
    quantity   integer,  
    PRIMARY KEY (product_no, order_id)  
);
```

Q: Приведите плюсы и минусы практики применения FOREIGN KEY
A: Плюсы: гарантированный контроль целостности данных на уровне базы данных без
лишних усилий. Минусы:

• возможно поймать неожиданное поведение RESTRICT / CASCADE и потерять данные
либо привести к ситуации когда при кажущейся целостности базы будут сломаны
контроли данных на уровне приложения вплоть до полной неработоспособности
• сложности в модификации схем данных при работе с шардами баз
• (самое важное что хотелось бы услышать) Для нагруженных приложений будут вызываться каскадные блокировки страниц данных всех связанных ключами таблиц, что скажется на производительности базы данных и времени отклика модифицирующих запросов. Так же, это приведет к сложностям при массовых манипуляциях с данными вплоть до полной потери производительноти до тех пор, пока не будет завершена большая модифицирующая транзакция. Большие риски поймать deadlock-и